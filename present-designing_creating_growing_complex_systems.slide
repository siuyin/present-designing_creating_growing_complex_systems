Designing, creating and growing
complex software systems 
12 Oct 2018

Loh Siu Yin
Technology Consultant, Beyond Broadcast LLP
siuyin@beyondbroadcast.com

* Complex Systems

* Simple system: A human individual

- Input: Vision, Sound, Touch, Smell, Taste

- Processing: Brain with a network of neurons

- Output: Classification task (Eg. feels good / feels bad)


* Complex system: A human community

- Input: Interpersonal relationships

- Processing: Community and Societal norms

- Output: Community standing (Eg. improved status / worsened status)

* Simple software: An individual worker

.play -edit simple/hello/main.go

This software worker:

Speaks Go Standard Library
Asks the _fmt_ standard library function to print "hello Go!"

A simple worker is a generalist that knows how to use the language's standard library.

---

An example of a human generalist is a clerk working in a bureaucracy.

* Specialist skills

.code skill/engineer/engineer.go

This package of engineering skill knows about building bridges and paving roads.
These skills are well-known and hence have capitalized names in Go.

We can place this specialist code in a software repository. Eg. https://github.com/siuyin/present-designing_creating_growing_complex_systems

* A capable worker

- Has a library of skills he has developed
- But is still an individual contributor

.play -edit simple/capable/main.go

* A specialist worker

Is a capable worker who can call upon a specialist skill(s) not present in the standard library.

.play -edit simple/specialist/main.go

He is still an individual contributor.

* Complex Software Systems

* A Complex Software System

- Is a community of software workers
- It comprises generalist and / or specialists workers
- These workers have varying capabilities and thier associated creation and maintenance costs.

---

Software Architecture is the organisation of these software workers, such that:

- The goal(s) of the System is met.
- The system can (easily) change to meet emerging goals.

* Organisation of software workers

* Human organisation structures

- Heirachical
- Collegial
- Cross-functional
- Project-based (Gotong Royong)
- Functional / Specialists

---

- Companies / Start-ups
- Societies / Guilds / Clubs
- Race / Religion
- Governments / Nations / States

* Software organisation structures

- Monoliths
- Microservices
- Service Oriented Architecture
- Software Libraries / Repositories

---

- Hard coded software
- Machine learning software
- Single-purpose software
- Multi-faceted software (eg. Busybox)

* What is "success"

- Human communities: community feels good
- Good leader
- Foresight / planning
- Able to make hard decisions

---

- Software systems: software fulfils purpose
- Readable
- Maintainable
- Extensible

* Business 101

- Responsibility / Accountability => Goals

---

- Specific
- Measurable
- Actionable
- Realistic
- Time-bound

* Organise by Resposibilities / Roles

- Human Responsibilities / Roles
- Board, CEO, CFO, CTO, other senior management etc
- Engineering, Operations, Development, Finance etc.
- XYZ product team / team lead

---

- Software Responsibility / Roles
- Frontend(s) / UI
- Customer (management)
- Order (management)
- Fulfillment (management)

* Implementing Responsibilities / Roles

- In a (human) start-up, CTO, CFO, Developer, Accountant may be handled by one person.
- A large enterprise may have a CTO and 200 developers.

---

- In a (software) start-up, all responsibilities and roles may be handled by one deployable, executable software artifact -- a monolith.
- A large software system may have tens of supporting services behind the main Customer service (module).

---

A set of deployables fulfill a reponsibility or role.
The responsibility or role is a hazy abstract concept. The deployable(s) implement that concept.

* Deployables

* Good human deployables / people / employees

- Independent worker
- Reliable
- Innovative
- Good communicator
- Skillful / competent (appropriate to the role / responsibility)
- Experienced (has learned well from exposure to past data)

* Good software deployables

- Independently deployable
- Single Responsibility
- Strong cohesion
- Well defined interface to facilitate substitution / replacecability
- Low dependency count (reports to a single master / supervisor / manager)
- High performance / low latency

* Complex worked example

* Complex

This example will be a webapp that adds two whole numbers (integers).

It is complex because it comprises more than one piece.

- Frontend -- the web interface
- Routing logic, routing web requests to the appropriate backend code
- Backend code, implementing the adding function

In short we will be implementing a Model, View, Controller architecture.


* Step 1: Naming responsibilities / roles

- Frontend -- interacts with users and outside world requests
- Main Lobby / Router -- connects requests to the appropriate backend worker
- Adder -- the worker that adds two integers

---

Adder is clearly a responsibility. Imagine a Multiplier responsibility to be added.

But what about Frontend and Main Lobby / Router ?
Their responsibility boundaries seem unclear to me.
Can we introduce a Multiplier without changes to Frontend and Router ?

* Should we just have one responsibility? Adder?

- Should Adder handle its own frontend and routing?

- When Multiplier is added it also handles its own frontend and routing.

Would this be confusing to the users who are confronted with different, potentially inconsistent frontends?

How could we resolve this tension?
